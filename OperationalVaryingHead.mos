model OperationalVaryingHead
uses "mmxprs"; !gain access to the Xpress-Optimizer solver

options explterm, noimplicit;

parameters
	TestFile = 'TestDataVar.txt';
	original = true;
	SOSimplementation = false;	
	Presolve = true;
	Heuristic = true;
	Cutting = 'Yes';
	Print = 'True';
end-parameters

declarations
	status:array({XPRS_OPT,XPRS_UNF,XPRS_INF,XPRS_UNB,XPRS_OTH}) of string;!for status of given solution
	timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp; ! assigns current "timestamp" to timetracker

!Declarations of sets
declarations
	nCycles:			integer;
	nMaxPeriods:		integer;
	nTurbines:			integer;
	nFlowBreakPoints:	integer;
	nHeadBreakPoints:	integer;
end-declarations
	
initializations from TestFile
	nCycles;
	nMaxPeriods;
	nTurbines;
	nFlowBreakPoints;
	nHeadBreakPoints;
end-initializations
	
declarations
	Cycles:			set of integer;
	Periods:		set of integer;
	Turbines:		set of integer;
	FlowBreakPoints:set of integer;
	HeadBreakPoints:set of integer;
	DiagCons:		set of integer;
end-declarations	

Cycles			:= 1 .. nCycles;!c
Periods			:= 1 .. nMaxPeriods;!t
Turbines		:= 1 .. nTurbines;!n
FlowBreakPoints	:= 1 .. nFlowBreakPoints;!r
HeadBreakPoints	:= 1 .. nHeadBreakPoints;!k
DiagCons 		:= 1 .. (nFlowBreakPoints+nHeadBreakPoints-1);!i	

finalize(Cycles);
finalize(Periods);
finalize(Turbines);
finalize(FlowBreakPoints);
finalize(HeadBreakPoints);
finalize(DiagCons);

!Declarations of parameters in matrix form	
declarations
	nPeriods:	array(Cycles)			of integer;	!number of production Periods in cycle c
	Volume0:	array(Cycles)			of integer;
	IsHighTide:	array(Cycles)			of integer;	!=1 if cycle starts in high tide, -1 otherwise
	Flow:		array(FlowBreakPoints)	of integer;!Flow in break point r
	Price:		array(Cycles,Periods)	of real;	!power price
	TideHead:	array(Cycles,Periods)	of real;	!estimated avg height difference in cycle c
	ResHead:	array(Cycles,HeadBreakPoints) of real;!Reservoir head in break point k
	Power:		array(Cycles,FlowBreakPoints,HeadBreakPoints)	of real;
end-declarations

initializations from TestFile
	nPeriods;
	Volume0;
	IsHighTide;
	Flow;
	Price;	
	TideHead;	
	ResHead;
	Power;
end-initializations

!Constants
declarations
	CFD:		integer;
	Duration:	integer;
	OprCost:	integer;
	Eta:		real;
	Rho:		integer;
	G:			real;
	Qmax:		integer;
	Qmin:		integer;
	Area:		real;
end-declarations
	
initializations from TestFile
	CFD;
	Duration;
	OprCost;
	Eta;
	Rho;
	G;
	Qmax;
	Qmin;
	Area;
end-initializations

!Variables
declarations	
	spill:		dynamic array (Cycles) of mpvar;
	power: 		dynamic array (Cycles,Periods) of mpvar;
	resHead:	dynamic array (Cycles,Periods)	of mpvar;
	head:		dynamic array (Cycles,Periods) of mpvar;
	flow:		dynamic array (Cycles,Periods,Turbines) of mpvar;
	starting:	dynamic array (Cycles,Periods,Turbines) of mpvar;
	running:	dynamic array (Cycles,Periods,Turbines) of mpvar;
	weight:		dynamic array (Cycles,Periods,Turbines,FlowBreakPoints,HeadBreakPoints)	of mpvar;
	sumHWeight:	dynamic array (Cycles,Periods, Turbines,FlowBreakPoints)	of mpvar;
	sumQWeight: dynamic array (Cycles,Periods, Turbines,HeadBreakPoints)	of mpvar;
	diagSum:	dynamic array (Cycles,Periods, Turbines,DiagCons)	of mpvar;
end-declarations

forall (cc in Cycles) do
	create(spill(cc));
end-do

forall (cc in Cycles, tt in Periods | tt<=nPeriods(cc)) do
	create(power(cc,tt));
	create(resHead(cc,tt));
	create(head(cc,tt));
end-do

forall (cc in Cycles, tt in Periods | tt<=nPeriods(cc),nn in Turbines) do
	create(flow(cc,tt,nn));
	create(starting(cc,tt,nn));
	create(running(cc,tt,nn));
	starting(cc,tt,nn) is_binary;
	running(cc,tt,nn) is_binary;
end-do

forall (cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines,rr in FlowBreakPoints,kk in HeadBreakPoints) do
	create(weight(cc,tt,nn,rr,kk));
end-do

forall(cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines,rr in FlowBreakPoints) do
	create(sumHWeight(cc,tt,nn,rr));
end-do

forall(cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines,kk in HeadBreakPoints) do
	create(sumQWeight(cc,tt,nn,kk));
end-do

forall(cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines,ii in DiagCons) do
	create(diagSum(cc,tt,nn,ii));
end-do

declarations
	ObjValue:		linctr;
	FlowCon:		dynamic array (Cycles, Periods, Turbines) of linctr;
	ResHeadCon:		dynamic array (Cycles, Periods) of linctr;
	PowerCon:		dynamic array (Cycles, Periods) of linctr;
	SumWeight:		dynamic array (Cycles, Periods, Turbines) of linctr;
	HeadFlowCon:	dynamic array (Cycles, Periods) of linctr;
	HeadCon:		dynamic array (Cycles, Periods) of linctr;
	TotalFlow:		dynamic array (Cycles) of linctr;
	MaxFlow:		dynamic array (Cycles, Periods, Turbines) of linctr;
	MinFlow:		dynamic array (Cycles, Periods, Turbines) of linctr;
	StartCon:		dynamic array (Cycles, Periods, Turbines) of linctr;
	StartCon0:		dynamic array (Cycles, Turbines) of linctr;
	Symmetry:		dynamic array (Cycles, Periods, Turbines) of linctr;
	SumHeadWeight:	dynamic array (Cycles, Periods, Turbines,FlowBreakPoints) of linctr;
	SumFlowWeight:	dynamic array (Cycles, Periods, Turbines,HeadBreakPoints) of linctr;
	SumDiag:		dynamic array (Cycles, Periods, Turbines,DiagCons) of linctr;
	SOS2R:			dynamic array (Cycles, Periods, Turbines) of linctr;
	SOS2K:			dynamic array (Cycles, Periods, Turbines) of linctr;
	SOS2Diag:		dynamic array (Cycles,Periods,Turbines) of linctr;
end-declarations

ObjValue :=
	sum(cc in Cycles,tt in Periods| tt<=nPeriods(cc))(Price(cc,tt)+CFD)*power(cc,tt)*Duration
	-
	sum(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines) OprCost*starting(cc,tt,nn);

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines) do
	FlowCon(cc,tt,nn):=
		flow(cc,tt,nn)=sum(rr in FlowBreakPoints,kk in HeadBreakPoints) Flow(rr)*weight(cc,tt,nn,rr,kk);
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc)) do
	ResHeadCon(cc,tt):=
		resHead(cc,tt)=sum(rr in FlowBreakPoints,kk in HeadBreakPoints,nn in Turbines) ResHead(cc,kk)*weight(cc,tt,nn,rr,kk);
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc)) do
	PowerCon(cc,tt):=
		power(cc,tt)=sum(rr in FlowBreakPoints,kk in HeadBreakPoints,nn in Turbines) Power(cc,rr,kk)*weight(cc,tt,nn,rr,kk);
end-do

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc), nn in Turbines) do
	SumWeight(cc,tt,nn):=
		sum(rr in FlowBreakPoints,kk in HeadBreakPoints) weight(cc,tt,nn,rr,kk)=1;
end-do

forall(cc in Cycles, tt in Periods|tt>1 and tt<=nPeriods(cc)) do
	HeadFlowCon(cc,tt):=
		resHead(cc,tt)<=resHead(cc,(tt-1))-IsHighTide(cc)*Duration/Area*sum(i in 1..(tt-1),nn in Turbines)flow(cc,tt,nn);
end-do		

forall(cc in Cycles, tt in Periods|tt>1 and tt<=nPeriods(cc)) do
	HeadCon(cc,tt):=
		head(cc,tt)=IsHighTide(cc)*resHead(cc,tt)-IsHighTide(cc)*TideHead(cc,tt);!production head =abs(ResHead-TideHead)
end-do		

forall(cc in Cycles) do! total flow <=Volume0 for sylindrical reservoir
	TotalFlow(cc):=
		sum(tt in Periods,nn in Turbines)flow(cc,tt,nn)+ spill(cc)= Volume0(cc);
end-do

forall(cc in Cycles,tt in Periods | tt<=nPeriods(cc),nn in Turbines) do
	MaxFlow(cc,tt,nn):=
		flow(cc,tt,nn)-Qmax*running(cc,tt,nn) <= 0;
end-do

forall(cc in Cycles,tt in Periods | tt<=nPeriods(cc),nn in Turbines) do
	MinFlow(cc,tt,nn):=
		flow(cc,tt,nn)-Qmin*running(cc,tt,nn) >= 0;
end-do

forall(cc in Cycles,tt in Periods | tt>1 and tt<=nPeriods(cc),nn in Turbines) do
	StartCon(cc,tt,nn):=
		running(cc,(tt-1),nn)+starting(cc,tt,nn)-running(cc,tt,nn)=0;
end-do

forall(cc in Cycles,nn in Turbines) do
	StartCon0(cc,nn):=
		starting(cc,1,nn)=running(cc,1,nn);
end-do

forall(cc in Cycles,tt in Periods | tt<=nPeriods(cc),nn in Turbines|nn<nTurbines) do
	Symmetry(cc,tt,nn):=
		flow(cc,tt,nn)-flow(cc,tt,(nn+1))>=0;
end-do

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines, rr in FlowBreakPoints) do
	SumHeadWeight(cc,tt,nn,rr):=
		sumHWeight(cc,tt,nn,rr) = sum(kk in HeadBreakPoints) weight(cc,tt,nn,rr,kk);
end-do

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines, kk in HeadBreakPoints) do
	SumFlowWeight(cc,tt,nn,kk):=
		sumQWeight(cc,tt,nn,kk) = sum(rr in FlowBreakPoints) weight(cc,tt,nn,rr,kk);
end-do

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines, ii in DiagCons) do
	SumDiag(cc,tt,nn,ii):=
		diagSum(cc,tt,nn,ii) = sum(rr in HeadBreakPoints|exists(weight(cc,tt,nn,rr,(ii+rr-nHeadBreakPoints))))weight(cc,tt,nn,rr,(ii+rr-nHeadBreakPoints));
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines) do
	SOS2R(cc,tt,nn):=
		sum(rr in FlowBreakPoints) rr*sumHWeight(cc,tt,nn,rr) is_sos2;
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines) do
	SOS2K(cc,tt,nn):=
		sum(kk in HeadBreakPoints) kk*sumQWeight(cc,tt,nn,kk) is_sos2;
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines) do
	SOS2Diag(cc,tt,nn):=
		sum(ii in DiagCons)ii*diagSum(cc,tt,nn,ii) is_sos2;
end-do

writeln("\nModel building completed in ", timestamp - timetracker, " seconds");
writeln("\nSolving model...");
timetracker := timestamp;
		

status::([XPRS_OPT,XPRS_UNF,XPRS_INF,XPRS_UNB,XPRS_OTH])[
                "Optimum found","Unfinished","Infeasible","Unbounded","Failed"];

maximize(ObjValue);

writeln("\nModel solved in ", timestamp - timetracker," seconds");
writeln("Status " + status(getprobstat));