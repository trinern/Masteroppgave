model OperationalVaryingHead
uses "mmxprs"; !gain access to the Xpress-Optimizer solver

options explterm, noimplicit;

parameters
	TestFile = 'TestDataVar.txt';
	original = true;
	SOSimplementation = false;	
	Presolve = true;
	Heuristic = true;
	Cutting = 'Yes';
	Print = 'True';
end-parameters

declarations
	status:array({XPRS_OPT,XPRS_UNF,XPRS_INF,XPRS_UNB,XPRS_OTH}) of string;!for status of given solution
	timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp; ! assigns current "timestamp" to timetracker

!Declarations of sets
declarations
	nCycles:			integer;
	nMaxPeriods:		integer;
	nTurbines:			integer;
	nFlowBreakPoints:	integer;
	nHeadBreakPoints:	integer;
	nScenarios:			integer;
	!nScenariosDA:		integer;
end-declarations
	
initializations from TestFile
	nCycles;
	nMaxPeriods;
	nTurbines;
	nFlowBreakPoints;
	nHeadBreakPoints;
	nScenarios;
	!nScenariosDA;
end-initializations
	
declarations
	Cycles:			set of integer;
	Periods:		set of integer;
	Turbines:		set of integer;
	FlowBreakPoints:set of integer;
	HeadBreakPoints:set of integer;
	DiagCons:		set of integer;
	Scenarios:		set of integer;
	!ScenariosDA:	set of integer;
end-declarations	

Cycles			:= 1 .. nCycles;!c
Periods			:= 1 .. nMaxPeriods;!t
Turbines		:= 1 .. nTurbines;!n
FlowBreakPoints	:= 1 .. nFlowBreakPoints;!r
HeadBreakPoints	:= 1 .. nHeadBreakPoints;!k
DiagCons 		:= 1 .. (nFlowBreakPoints+nHeadBreakPoints-1);!i	
Scenarios		:= 1 .. nScenarios;!s

finalize(Cycles);
finalize(Periods);
finalize(Turbines);
finalize(FlowBreakPoints);
finalize(HeadBreakPoints);
finalize(DiagCons);
finalize(Scenarios);

!Declarations of parameters in matrix form
!Matlab generated matrices must be written in the form (dim3, dim2, dim1) for proper reading	
declarations
	nPeriods:	array(Cycles)			of real;	!number of production Periods in cycle c
	IsHighTide:	array(Cycles)			of integer;	!=1 if cycle starts in high tide, -1 otherwise
	Flow:		array(FlowBreakPoints)	of real;!Flow in break point r
	PriceDA:	array(Cycles,Periods,Scenarios)	of real;	!power price
	PriceRT:	array(Cycles,Periods,Scenarios)	of real;	!power price
	ResHead:	array(Cycles,HeadBreakPoints) of real;!Reservoir head in break point k
	Power:		array(Cycles, Periods, FlowBreakPoints, HeadBreakPoints )	of real;
	Prob:		array(Scenarios)	of real;
	StartH:		array(Cycles)	of real;
end-declarations

initializations from TestFile
	nPeriods;
	IsHighTide;
	Flow;
	PriceDA;	
	PriceRT;	
	ResHead;
	Power;
	Prob;
	StartH;
end-initializations

!Constants
declarations
	CFD:		integer;
	Duration:	integer;
	OprCost:	integer;
	Eta:		real;
	Rho:		integer;
	G:			real;
	Qmax:		integer;
	Qmin:		integer;
	Area:		real;
	Factor_Period: real;
	TurbineD:	real;
	PowerFactor:integer;
	MaxPower:	integer;
	TurbineCost:integer;
end-declarations
	
initializations from TestFile
	CFD;
	Duration;
	OprCost;
	Eta;
	Rho;
	G;
	Qmax;
	Qmin;
	Area;
	Factor_Period;
	TurbineD;
	PowerFactor;
	MaxPower;
	TurbineCost;
end-initializations

!Variables
declarations	
	spill:		dynamic array (Cycles,Scenarios) of mpvar;
	soldDA:		dynamic array(Cycles, Periods, Scenarios) of mpvar;
	soldRT:		dynamic array(Cycles, Periods, Scenarios) of mpvar;
	power: 		dynamic array (Cycles,Periods,Turbines,Scenarios) of mpvar;
	resHeadTurbine:	dynamic array (Cycles,Periods,Turbines,Scenarios)	of mpvar;!turbine specific resHead
	resHead:	dynamic array (Cycles,Periods,Scenarios)	of mpvar;!turbine indep res head
	flow:		dynamic array (Cycles,Periods,Turbines,Scenarios) of mpvar;
	starting:	dynamic array (Cycles,Periods,Turbines,Scenarios) of mpvar;
	running:	dynamic array (Cycles,Periods,Turbines,Scenarios) of mpvar;
	weight:		dynamic array (Cycles,Periods,Turbines,Scenarios,FlowBreakPoints,HeadBreakPoints)	of mpvar;
	sumHWeight:	dynamic array (Cycles,Periods, Turbines,Scenarios,FlowBreakPoints)	of mpvar;
	sumQWeight: dynamic array (Cycles,Periods, Turbines,Scenarios,HeadBreakPoints)	of mpvar;
	diagSum:	dynamic array (Cycles,Periods, Turbines,Scenarios,DiagCons)	of mpvar;
	!!!Turbine opt!!!
	builtTurbine:dynamic array (Turbines) of mpvar;
end-declarations

forall (cc in Cycles, ss in Scenarios) do
	create(spill(cc,ss));
end-do

forall (cc in Cycles, tt in Periods | tt<=nPeriods(cc), ss in Scenarios) do
	create(resHead(cc,tt,ss));
	!create(head(cc,tt,ss));
	create(soldDA(cc,tt,ss));
	create(soldRT(cc,tt,ss));
	resHead(cc,tt,ss) is_free;
end-do

forall (cc in Cycles, tt in Periods | tt<=nPeriods(cc),nn in Turbines, ss in Scenarios) do
	create(flow(cc,tt,nn,ss));
	create(resHeadTurbine(cc,tt,nn,ss));
	create(power(cc,tt,nn,ss));
	create(starting(cc,tt,nn,ss));
	create(running(cc,tt,nn,ss));
	resHeadTurbine(cc,tt,nn,ss) is_free;
	starting(cc,tt,nn,ss) is_binary;
	running(cc,tt,nn,ss) is_binary;
end-do

forall (cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines, ss in Scenarios, rr in FlowBreakPoints,kk in HeadBreakPoints) do
	create(weight(cc,tt,nn,ss,rr,kk));	
end-do

forall(cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines, ss in Scenarios,rr in FlowBreakPoints) do
	create(sumHWeight(cc,tt,nn,ss,rr));
end-do

forall(cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines, ss in Scenarios,kk in HeadBreakPoints) do
	create(sumQWeight(cc,tt,nn,ss,kk));
end-do

forall(cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines, ss in Scenarios,ii in DiagCons) do
	create(diagSum(cc,tt,nn,ss,ii));
end-do

!!TurbineOpt!!
forall(nn in Turbines) do
	create(builtTurbine(nn));
	builtTurbine(nn) is_binary;
end-do

declarations
	ObjValue:		linctr;
	FlowCon:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	ResHeadCon:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	ResHeadFixCon:	dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	PowerCon:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	ProdSalesBal:	dynamic array (Cycles, Periods, Scenarios) of linctr;
	SalesLimDA:		dynamic array (Cycles, Periods, Scenarios) of linctr;
	SumWeight:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	HeadFlowCon:	dynamic array (Cycles, Periods, Scenarios) of linctr;
	FeasibleGrid:	dynamic array (Cycles, Periods, Turbines, Scenarios, FlowBreakPoints, HeadBreakPoints) of linctr;
	HeadCon:		dynamic array (Cycles, Periods, Scenarios) of linctr;
	TotalFlow:		dynamic array (Cycles, Scenarios) of linctr;
	MaxFlow:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	MinFlow:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	StartCon:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	Symmetry:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	SumHeadWeight:	dynamic array (Cycles, Periods, Turbines, Scenarios,FlowBreakPoints) of linctr;
	SumFlowWeight:	dynamic array (Cycles, Periods, Turbines, Scenarios,HeadBreakPoints) of linctr;
	SumDiag:		dynamic array (Cycles, Periods, Turbines, Scenarios,DiagCons) of linctr;
	SOS2R:			dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	SOS2K:			dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	SOS2Diag:		dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
	MaxPowerCon:	dynamic array (Cycles, Periods, Turbines, Scenarios) of linctr;
end-declarations

ObjValue :=
	sum(ss in Scenarios)Prob(ss)*(
		sum(cc in Cycles,tt in Periods| tt<=nPeriods(cc))(PriceDA(cc,tt,ss)*soldDA(cc,tt,ss)+PriceRT(cc,tt,ss)*soldRT(cc,tt,ss))
		-
		sum(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines) OprCost*starting(cc,tt,nn,ss)
		-
		sum(nn in Turbines) TurbineCost*builtTurbine(nn)
		);

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines,ss in Scenarios) do
	FlowCon(cc,tt,nn,ss):=
		flow(cc,tt,nn,ss)=sum(rr in FlowBreakPoints,kk in HeadBreakPoints) Flow(rr)*weight(cc,tt,nn,ss,rr,kk);
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines,ss in Scenarios) do
	ResHeadCon(cc,tt,nn,ss):=
		resHeadTurbine(cc,tt,nn,ss)=sum(rr in FlowBreakPoints,kk in HeadBreakPoints) ResHead(cc,kk)*weight(cc,tt,nn,ss,rr,kk);
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines,ss in Scenarios) do
	ResHeadFixCon(cc,tt,nn,ss):=
		resHead(cc,tt,ss)=resHeadTurbine(cc,tt,nn,ss);
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines,ss in Scenarios) do
	PowerCon(cc,tt,nn,ss):=
		power(cc,tt,nn,ss)=sum(rr in FlowBreakPoints,kk in HeadBreakPoints) Power(cc,tt,rr,kk)*weight(cc,tt,nn,ss,rr,kk);
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc),ss in Scenarios) do
	ProdSalesBal(cc,tt,ss):=
		soldDA(cc,tt,ss) + soldRT(cc,tt,ss) <= sum(nn in Turbines)power(cc,tt,nn,ss)*Factor_Period/PowerFactor;
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc),ss in Scenarios) do
	SalesLimDA(cc,tt,ss):=
		soldDA(cc,tt,ss)<= sum(nn in Turbines)builtTurbine(nn)*MaxPower*Factor_Period/PowerFactor;
end-do

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc), nn in Turbines,ss in Scenarios) do
	SumWeight(cc,tt,nn,ss):=
		sum(rr in FlowBreakPoints,kk in HeadBreakPoints) weight(cc,tt,nn,ss,rr,kk)=1;
end-do

forall(cc in Cycles, tt in Periods|tt>1 and tt<=nPeriods(cc),ss in Scenarios) do
	HeadFlowCon(cc,tt,ss):=
		resHead(cc,tt,ss)=resHead(cc,(tt-1),ss)-IsHighTide(cc)*Duration/Area*sum(i in 1..(tt-1),nn in Turbines)flow(cc,tt,nn,ss);
end-do	

forall(cc in Cycles, ss in Scenarios) do
	HeadFlowCon(cc,1,ss):=
		resHead(cc,1,ss)=StartH(cc);
end-do		

(!forall(cc in Cycles,tt in Periods|tt<=nPeriods(cc),nn in Turbines, ss in Scenarios, rr in FlowBreakPoints,kk in HeadBreakPoints) do
	FeasibleGrid(cc,tt,nn,ss,rr,kk):=
		flow(cc,tt,nn,ss)<=3.14/4*sqrt(2*G*resHeadTurbine(cc,tt,nn,ss))*TurbineD;!flow restriction depending on height
end-do!)
		

forall(cc in Cycles,ss in Scenarios) do! total flow <=Volume0 for sylindrical reservoir
	TotalFlow(cc,ss):=
		sum(tt in Periods,nn in Turbines)flow(cc,tt,nn,ss)+ spill(cc,ss)= 2*IsHighTide(cc)*StartH(cc)*Area;
end-do

forall(cc in Cycles,tt in Periods | tt<=nPeriods(cc),nn in Turbines,ss in Scenarios) do
	MaxFlow(cc,tt,nn,ss):=
		flow(cc,tt,nn,ss)-Qmax*running(cc,tt,nn,ss) <= 0;
end-do

forall(cc in Cycles,tt in Periods | tt<=nPeriods(cc),nn in Turbines,ss in Scenarios) do
	MinFlow(cc,tt,nn,ss):=
		flow(cc,tt,nn,ss)-Qmin*running(cc,tt,nn,ss) >= 0;
end-do

forall(cc in Cycles,tt in Periods | tt>1 and tt<=nPeriods(cc),nn in Turbines,ss in Scenarios) do
	StartCon(cc,tt,nn,ss):=
		running(cc,(tt-1),nn,ss)+starting(cc,tt,nn,ss)-running(cc,tt,nn,ss)>=0;
end-do

forall(cc in Cycles,nn in Turbines,ss in Scenarios) do
	StartCon(cc,1,nn,ss):=
		starting(cc,1,nn,ss)=running(cc,1,nn,ss);
end-do

forall(cc in Cycles,tt in Periods | tt<=nPeriods(cc),nn in Turbines|nn<nTurbines,ss in Scenarios) do
	Symmetry(cc,tt,nn,ss):=
		flow(cc,tt,nn,ss)-flow(cc,tt,(nn+1),ss)>=0;
end-do

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines,ss in Scenarios,rr in FlowBreakPoints) do
	SumHeadWeight(cc,tt,nn,ss,rr):=
		sumHWeight(cc,tt,nn,ss,rr) = sum(kk in HeadBreakPoints) weight(cc,tt,nn,ss,rr,kk);
end-do

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines,ss in Scenarios, kk in HeadBreakPoints) do
	SumFlowWeight(cc,tt,nn,ss,kk):=
		sumQWeight(cc,tt,nn,ss,kk) = sum(rr in FlowBreakPoints) weight(cc,tt,nn,ss,rr,kk);
end-do

forall(cc in Cycles,tt in Periods| tt<=nPeriods(cc),nn in Turbines,ss in Scenarios, ii in DiagCons) do
	SumDiag(cc,tt,nn,ss,ii):=
		diagSum(cc,tt,nn,ss,ii) = sum(rr in HeadBreakPoints|exists(weight(cc,tt,nn,ss,rr,(ii+rr-nHeadBreakPoints))))weight(cc,tt,nn,ss,rr,(ii+rr-nHeadBreakPoints));
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines,ss in Scenarios) do
	SOS2R(cc,tt,nn,ss):=
		sum(rr in FlowBreakPoints) rr*sumHWeight(cc,tt,nn,ss,rr) is_sos2;
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines,ss in Scenarios) do
	SOS2K(cc,tt,nn,ss):=
		sum(kk in HeadBreakPoints) kk*sumQWeight(cc,tt,nn,ss,kk) is_sos2;
end-do

forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines,ss in Scenarios) do
	SOS2Diag(cc,tt,nn,ss):=
		sum(ii in DiagCons)ii*diagSum(cc,tt,nn,ss,ii) is_sos2;
end-do

!!TurbineOpt
forall(cc in Cycles, tt in Periods| tt<=nPeriods(cc), nn in Turbines,ss in Scenarios) do
	MaxPowerCon(cc,tt,nn,ss):=
		power(cc,tt,nn,ss)<=builtTurbine(nn)*MaxPower;
end-do

writeln("\nModel building completed in ", timestamp - timetracker, " seconds");
writeln("\nSolving model...");
timetracker := timestamp;
		

status::([XPRS_OPT,XPRS_UNF,XPRS_INF,XPRS_UNB,XPRS_OTH])[
                "Optimum found","Unfinished","Infeasible","Unbounded","Failed"];

maximize(ObjValue);

writeln("\nModel solved in ", timestamp - timetracker," seconds");
writeln("Status: " + status(getprobstat));