model OperationalModel
uses "mmxprs"; !gain access to the Xpress-Optimizer solver

options explterm, noimplicit;

parameters
	TestFile = 'TestData.txt';
	original = true;
	SOSimplementation = false;	
	Presolve = true;
	Heuristic = true;
	Cutting = 'Yes';
	Print = 'True';
end-parameters

declarations
	status:array({XPRS_OPT,XPRS_UNF,XPRS_INF,XPRS_UNB,XPRS_OTH}) of string;!for status of given solution
	timetracker:	real; ! used to log timestamps for time consumption output
end-declarations

writeln("Building model...");
timetracker := timestamp; ! assigns current "timestamp" to timetracker

!Declarations of sets
declarations
	nCycles:			integer;
	nIntervals:			integer;
	nTurbines:			integer;
end-declarations
	
initializations from TestFile
	nCycles;
	nIntervals;
	nTurbines;
end-initializations
	
declarations
	Cycles:			set of integer;
	Intervals:		set of integer;
	Turbines:		set of integer;
end-declarations	

Cycles		:= 1 .. nCycles;!c
Intervals	:= 1 .. nIntervals;!t
Turbines	:= 1 .. nTurbines;!n

finalize(Cycles);
finalize(Intervals);
finalize(Turbines);

!Declarations of parameters in matrix form	
declarations
	Price:		array(Cycles,Intervals)	of real;	!power price
	Height:		array(Cycles)			of real;	!estimated avg height difference in cycle c
	Volume0:	array(Cycles)			of real;	!largest reservoir volume in cycle c
end-declarations
	
initializations from TestFile
	Price;
	Height;
	Volume0;
end-initializations

!Constants
declarations
	CFD:		integer;
	Duration:	integer;
	OprCost:	integer;
	Eta:		real;
	Rho:		integer;
	G:			real;
	Qmax:		integer;
	Qmin:		integer;
end-declarations
	
initializations from TestFile
	CFD;
	Duration;
	OprCost;
	Eta;
	Rho;
	G;
	Qmax;
	Qmin;
end-initializations

!Variables
declarations	
	power: 		dynamic array (Cycles,Intervals) of mpvar;
	flow:		dynamic array (Cycles,Intervals,Turbines) of mpvar;
	starting:	dynamic array (Cycles,Intervals,Turbines) of mpvar;
	running:	dynamic array (Cycles,Intervals,Turbines) of mpvar;
end-declarations

forall (cc in Cycles, tt in Intervals) do
	create(power(cc,tt));
end-do

forall (cc in Cycles, tt in Intervals,nn in Turbines) do
	create(flow(cc,tt,nn));
	create(starting(cc,tt,nn));
	create(running(cc,tt,nn));
	flow(cc,tt,nn) is_free;
	starting(cc,tt,nn) is_binary;
	running(cc,tt,nn) is_binary;
end-do

declarations
	ObjValue:		linctr;
	Power:			dynamic array (Cycles, Intervals) of linctr;
	TotalFlow:		dynamic array (Cycles) of linctr;
	MaxFlow:		dynamic array (Cycles, Intervals, Turbines) of linctr;
	MinFlow:		dynamic array (Cycles, Intervals, Turbines) of linctr;
	StartCon:		dynamic array (Cycles, Intervals, Turbines) of linctr;
	StartCon0:		dynamic array (Cycles, Turbines) of linctr;
	Symmetry:		dynamic array (Cycles, Intervals, Turbines) of linctr;
end-declarations

ObjValue :=
	sum(cc in Cycles,tt in Intervals)(Price(cc,tt)+CFD)*power(cc,tt)*Duration
	-
	sum(cc in Cycles,tt in Intervals,nn in Turbines) OprCost*starting(cc,tt,nn);
	
forall(cc in Cycles,tt in Intervals) do
	Power(cc,tt):=
		power(cc,tt)= sum(nn in Turbines)Eta*Rho*G*Height(cc)*flow(cc,tt,nn);
end-do

forall(cc in Cycles) do
	TotalFlow(cc):=
		sum(tt in Intervals,nn in Turbines)(flow(cc,tt,nn)) <= abs(Volume0(cc));
end-do

forall(cc in Cycles,tt in Intervals,nn in Turbines) do
	MaxFlow(cc,tt,nn):=
		flow(cc,tt,nn)-Qmax*running(cc,tt,nn) <= 0;
end-do

forall(cc in Cycles,tt in Intervals,nn in Turbines) do
	MinFlow(cc,tt,nn):=
		flow(cc,tt,nn)-Qmin*running(cc,tt,nn) >= 0;
end-do

forall(cc in Cycles,tt in Intervals|tt>1,nn in Turbines) do
	StartCon(cc,tt,nn):=
		running(cc,(tt-1),nn)+starting(cc,tt,nn)-running(cc,tt,nn)=0;
end-do

forall(cc in Cycles,nn in Turbines) do
	StartCon0(cc,nn):=
		starting(cc,1,nn)=running(cc,1,nn);
end-do

forall(cc in Cycles,tt in Intervals,nn in Turbines|nn<nTurbines) do
	Symmetry(cc,tt,nn):=
		flow(cc,tt,nn)-flow(cc,tt,(nn+1))>=0;
end-do


writeln("\nModel building completed in ", timestamp - timetracker, " seconds");
writeln("\nSolving model...");
timetracker := timestamp;
		

status::([XPRS_OPT,XPRS_UNF,XPRS_INF,XPRS_UNB,XPRS_OTH])[
                "Optimum found","Unfinished","Infeasible","Unbounded","Failed"];

maximize(ObjValue);

writeln("\nModel solved in ", timestamp - timetracker," seconds");
writeln("Status " + status(getprobstat));